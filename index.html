<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>湖人总冠军</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="湖人总冠军">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="湖人总冠军">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="湖人总冠军">
  
    <link rel="alternate" href="/atom.xml" title="湖人总冠军" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">湖人总冠军</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-基于swoole的服务治理(二)：RPC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/基于swoole的服务治理(二)：RPC/" class="article-date">
  <time datetime="2018-03-04T11:50:23.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/基于swoole的服务治理(二)：RPC/">基于swoole的服务治理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/04/基于swoole的服务治理(二)：RPC/" data-id="cjecqlwmc00012wx9rab4u7yl" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基于swoole的服务治理(一)：概述" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/基于swoole的服务治理(一)：概述/" class="article-date">
  <time datetime="2018-03-04T11:34:14.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/基于swoole的服务治理(一)：概述/">基于swoole的服务治理(一)：概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个系列，是基于梦康大佬的课程所做的整理<a href="https://segmentfault.com/l/1500000011300619" target="_blank" rel="noopener">https://segmentfault.com/l/1500000011300619</a></p>
<h2 id="1-服务治理和微服务的关系"><a href="#1-服务治理和微服务的关系" class="headerlink" title="1.服务治理和微服务的关系"></a>1.服务治理和微服务的关系</h2><p><strong>服务治理</strong>用来实现各个微服务实例的注册与发现，是<strong>微服务架构中最关键的基础设施</strong>。 </p>
<p>一个服务治理框架一般由以下两部分组成：<strong>服务注册</strong>和<strong>服务发现</strong>。</p>
<h2 id="2-服务注册"><a href="#2-服务注册" class="headerlink" title="2.服务注册"></a>2.服务注册</h2><p><strong>服务注册中心</strong>：每个服务实例会向注册中心注册自己的信息，一般包含地址、端口、协议、版本等信息。每种服务会有多个实例副本注册到注册中心，<strong>注册中心维护每种服务的多个实例列表</strong>。同时，注册中心会以某种机制去检查各个服务实例是否可用，如果某个实例已经失效会将其剔除。在某个服务实例关闭时会自动向注册中心注销自己。</p>
<p><img src="1.png" alt=""></p>
<p>上图就是用数据库当作注册中心，UserService这个用户服务有两个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常见的服务注册有两种实现方式：</span><br><span class="line"> </span><br><span class="line">1）服务进程内直接包含服务注册模块，即把服务注册的功能写到了服务的源代码中，由服务实例自己完成上线注册和下线注销。这种方式对客户端要求比较高，尤其是众多服务采用不同的语言开发的时候</span><br><span class="line">2）由一个伙伴进程或一个中间的调度者来帮助处理服务注册</span><br></pre></td></tr></table></figure>
<p>这两种实现方式都有PHP例子，第一种是韩天峰的swoole方式，第二种是有赞的haunt方式。</p>
<p>第1种：参考<a href="https://github.com/ThinkDevelopers/PHPConChina/blob/master/PHPCON2017/%E8%BD%A6%E8%BD%AESwoole%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84--%E9%9F%A9%E5%A4%A9%E5%B3%B0%40PHPCON2017.pdf" target="_blank" rel="noopener">https://github.com/ThinkDevelopers/PHPConChina/blob/master/PHPCON2017/%E8%BD%A6%E8%BD%AESwoole%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84–%E9%9F%A9%E5%A4%A9%E5%B3%B0%40PHPCON2017.pdf</a></p>
<p><img src="2.png" alt=""></p>
<p>第2种：参考<a href="https://tech.youzan.com/haunt-youzan-service-discovery/" target="_blank" rel="noopener">https://tech.youzan.com/haunt-youzan-service-discovery/</a></p>
<p><img src="3.png" alt=""></p>
<h2 id="3-服务发现"><a href="#3-服务发现" class="headerlink" title="3.服务发现"></a>3.服务发现</h2><p>服务发现即客户端在其网络上找到其要调用服务的具体连接信息的过程。例如<strong>通过查询服务注册中心得到其所调用服务的具体 IP地址和端口</strong>。 简单的说，服务发现就是服务或者应用之间互相定位的过程。</p>
<p>服务发现也有几种常见的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）静态配置：这种实现基本上不用考虑，为了实现服务的高可用需要手动维护服务实例副本的列表，显然不适合微服务架构下众多的服务以及服务治理的自动化需求。</span><br><span class="line">2）服务端负载均衡器：由服务端的负载均衡器通过服务注册中心中服务实例信息动态生成和更新代理和负载均衡配置，一般服务注册中心会在服务上线注册、下线注销、失效剔除时推送信息给服务端负载均衡器。这种方式实际上是在服务端实现的服务发现。</span><br><span class="line">3）客户端负载均衡器：由客户端的负载均衡器通过服务注册中心中服务实例信息动态生成和更新代理和负载均衡配置。这种方式是在客户端即服务调用方端实现的服务发现。</span><br><span class="line">4）客户端集成服务发现：一般以SDK的形式集成到客户端进程内</span><br></pre></td></tr></table></figure>
<p>据目前了解，一般是结合2和3的方式去做服务发现。方式2是注册中心会马上感应到服务的配置变更、异常，但通知给该服务的各个调用者有一定的延时，服务都挂了，调用方还去请求；方式3客户端与服务注册中心绑定，要针对服务端用到的每个编程语言和框架，实现客户端的服务发现逻辑；而且对于服务治理不是非常友好。(待细究)</p>
<h2 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4.负载均衡"></a>4.负载均衡</h2><p>服务发现除了实现方式，还需要一个负载均衡算法。</p>
<p>负载均衡很容易想到Nginx，Nginx有5种方式，轮询（默认）、加权轮询、ip_hash、fair和url_hash。</p>
<p>后端不同服务器性能不均衡的情况下，负载均衡算法选择“加权轮询”是比较常见的做法，也是比较一般的做法…不那么一般的算法，就可以参考Zookeeper、Consul等等。</p>
<p>Nginx版加权轮询，可以参考<a href="http://blog.csdn.net/zhangskd/article/details/50194069" target="_blank" rel="noopener">http://blog.csdn.net/zhangskd/article/details/50194069</a></p>
<p>PHP版加权轮询，根据上面的博客，也可以轻松写出。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 假设这是从注册中心（数据库）拿到的数据，UserService有3个实例a,b,c，权重值分别设为4，2，1</span></span><br><span class="line">$list = [</span><br><span class="line">    <span class="string">'a'</span> =&gt; [</span><br><span class="line">        <span class="string">'effective_weight'</span> =&gt; <span class="number">4</span>,</span><br><span class="line">        <span class="string">'current_weight'</span> =&gt; <span class="number">0</span></span><br><span class="line">        ],</span><br><span class="line">    <span class="string">'b'</span> =&gt; [</span><br><span class="line">        <span class="string">'effective_weight'</span> =&gt; <span class="number">2</span>,</span><br><span class="line">        <span class="string">'current_weight'</span> =&gt; <span class="number">0</span></span><br><span class="line">        ],</span><br><span class="line">    <span class="string">'c'</span> =&gt; [</span><br><span class="line">        <span class="string">'effective_weight'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">        <span class="string">'current_weight'</span> =&gt; <span class="number">0</span></span><br><span class="line">        ],</span><br><span class="line">    ];</span><br><span class="line">     </span><br><span class="line">$data = [];</span><br><span class="line">$totalWeight = <span class="number">7</span>;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">foreach</span> ($list <span class="keyword">as</span> $key =&gt; $item) &#123;</span><br><span class="line">    $data[$key][<span class="string">'current_weight'</span>] += $item[<span class="string">'effective_weight'</span>];</span><br><span class="line">&#125;</span><br><span class="line">$selected = array_keys($data, max($data));</span><br><span class="line">$data[$selected[<span class="number">0</span>]][<span class="string">'current_weight'</span>] -= $totalWeight;</span><br><span class="line">var_dump($selected,$data);</span><br></pre></td></tr></table></figure>
<p>上面是服务实例的负载均衡，它满足了大部分人需求，但总有一些需求真是你想都想不到…</p>
<p>比如，用户服务暴露了两个方法，getUserInfo和isSingle，用户服务方觉得isSingle方法调用频率相当高（根据监控中心数据），是getUserInfo的好几倍，于是用户服务方决定写个规则，凡是调用isSingle方法的都转到服务器b和c，不提供getUserInfo，要getUserInfo只能去调用服务器a。</p>
<p>又比如，用户服务有两个services，一个是UserService, 一个是DriverService，也是根据监控中心发现DriverService明显被频繁调用，于是又写一条规则…</p>
<p>这些都是属于负载均衡，在服务发现之后，选择服务前做的事情。</p>
<h2 id="5-服务下线"><a href="#5-服务下线" class="headerlink" title="5.服务下线"></a>5.服务下线</h2><p>服务下线正常流程都会去通知注册中心，注册中心再去通知客户端消费者。但弊端也如前文所述，会有延时，除此之外，服务自己出现异常，然后挂了，它是不会去通知注册中心的。所以这时候应该怎么办？</p>
<p>应该引入心跳机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">什么是心跳机制？</span><br><span class="line">心跳机制就是业务层来提供一个连接是否存活的一个方法，让系统能判定一个连接是否失效。一般有两种实现方式：</span><br><span class="line">1： 客户端定时发送一个心跳包，告诉服务器我还活着，服务器定时检测所有客户端列表，看他们最后一个心跳包的时间是否过长，如果过长，则认为已无心跳，判定为死连接，主动关闭这个连接。</span><br><span class="line">2： 服务器定时询问所有的客户端，你们还在么？如果在，给我个回馈,没得到回馈的客户端，就是不在了..</span><br><span class="line">两种心跳方案有什么区别？</span><br><span class="line">第一种方案，对服务器和网络的压力更小，而且更具有灵活性，但需要客户端配合定时发送心跳包。</span><br><span class="line">第二种方案，对服务器和网络压力更大，不建议使用。</span><br></pre></td></tr></table></figure>
<p>但韩天峰在大会上分享的做法是起一个KeepAlived守护进程</p>
<p><img src="4.png" alt=""></p>
<h2 id="6-再谈谈服务治理跟微服务的关系"><a href="#6-再谈谈服务治理跟微服务的关系" class="headerlink" title="6.再谈谈服务治理跟微服务的关系"></a>6.再谈谈服务治理跟微服务的关系</h2><p>在整理服务治理相关内容时候，服务注册、发现、负载均衡、下线，还有服务鉴权和服务监控，发现一个治理都要做这么多工作，让我很容易想到微服务的网关，这些工作不也是网关干的吗？</p>
<p>随便网上搜微服务的架构，大都是：<strong>微服务=服务网关+Restful Api</strong></p>
<p>而且大部分博客真的是都喜欢引用这张图…</p>
<p><img src="5.png" alt=""></p>
<p>但是服务治理的架构是这样的：<strong>服务治理=注册中心+服务接口</strong></p>
<p>后来听了老司机的课程，<strong>其实微服务整体架构是对外的，服务治理整体架构是对内的</strong>，可以结合下图理解。</p>
<p><img src="6.png" alt=""></p>
<p>虚线左边就是一个网关跟很多API，给Web端，App端等等通过restful方式请求访问，这是<strong>对外</strong>；</p>
<p>虚线右边就是服务治理，一个API请求会调用一个或者多个服务，这些服务落在不同服务器上，就需要服务治理，这是<strong>对内</strong>。</p>
<p>外面的Web，APP端不可能直达服务治理中心，客户端也不懂后端各种Service，然后直接调用Service方法，当然，对内东西对外暴露也不安全。</p>
<p>更详细的讲解可以看看这篇文章 <a href="http://blog.csdn.net/suifeng3051/article/details/53992560" target="_blank" rel="noopener">http://blog.csdn.net/suifeng3051/article/details/53992560</a>，看了这篇文章，思路会更加清晰，这也解决了我另一个疑惑，为什么大佬们做微服务都想到java，想到Dubbo和Spring Cloud。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/04/基于swoole的服务治理(一)：概述/" data-id="cjecqlwm000002wx9av8qd3gy" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-怎么写一个高性能的服务器(四)：总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/怎么写一个高性能的服务器(四)：总结/" class="article-date">
  <time datetime="2018-03-04T10:48:19.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/怎么写一个高性能的服务器(四)：总结/">怎么写一个高性能的服务器(四)：总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="1.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/04/怎么写一个高性能的服务器(四)：总结/" data-id="cjecqlwms00052wx9tg65rc2a" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-怎么写一个高性能的服务器(三)：开源分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/怎么写一个高性能的服务器(三)：开源分析/" class="article-date">
  <time datetime="2018-03-04T10:11:57.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/怎么写一个高性能的服务器(三)：开源分析/">怎么写一个高性能的服务器(三)：开源分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-redis是单线程的服务器"><a href="#1-redis是单线程的服务器" class="headerlink" title="1.redis是单线程的服务器"></a><strong>1.redis是单线程的服务器</strong></h2><p>Reactor模型就是一个不断循环等待的单独线程，就一个EvenLoop，redis是Reactor模式最简单的版本。</p>
<p><strong>所以，Redis的事件循环是在单线程中进行的，因此要确保快速的进行事件处理，这样事件循环中的后续任务才不会被阻塞。</strong></p>
<p>在Redis中影响时延的场景主要有三种：</p>
<ul>
<li>耗时长的命令造成的阻塞；</li>
<li>fork产生的阻塞；</li>
<li>持久化造成的阻塞；</li>
</ul>
<p><strong>耗时长的命令造成的阻塞</strong></p>
<p>耗时长的命令主要包括keys、sort、smembers等。</p>
<p><strong>对于keys命令</strong>，它是用于查找所有符合给定模式pattern的key，时间复杂度为O(N)， N为数据库中key的数量。当数据库中的个数达到千万时，这个命令会造成读写线程阻塞数秒。类似的命令有sunion sort等操作。</p>
<p><strong>对于smembers命令</strong>，它是用于获取集合全集，时间复杂度为O(N)，N为集合中的数量。如果一个集合中保存了千万级的数据，一次性取回也会造成事件处理线程的长时间阻塞。</p>
<p>解决方案：</p>
<p><strong>keys</strong>：将它分离出去，比如单独使用<strong>一个redis从节点</strong>专门用于keys、sort等耗时操作，通常这些查询<strong>一般不会是线上的实时业务</strong>，对时延要求不高。</p>
<p><strong>smembers：</strong>smembers是线上实时应用场景中使用频率非常高的一个命令，<strong>可以从设计层面来考虑： 可以控制集合的数量。</strong>比如原来使用一个键来存储一年的记录，数据量大，我们可以使用12个键来分别保存12个月的记录，或者365个键来保存每一天的记录，将集合的规模控制在可接受的范围。</p>
<p><img src="1.png" alt=""></p>
<p>后面两个问题，平时较少用到，参考 <a href="http://webcache.googleusercontent.com/search?q=cache:tRr5yWYYvLMJ:www.tk4479.net/tian_ex/article/details/53283871+&amp;cd=8&amp;hl=zh-CN&amp;ct=clnk" target="_blank" rel="noopener">http://webcache.googleusercontent.com/search?q=cache:tRr5yWYYvLMJ:www.tk4479.net/tian_ex/article/details/53283871+&amp;cd=8&amp;hl=zh-CN&amp;ct=clnk</a></p>
<h2 id="2-Memcache是基于libevent，libevent是个高性能网络库，也是基于Reactor模型。"><a href="#2-Memcache是基于libevent，libevent是个高性能网络库，也是基于Reactor模型。" class="headerlink" title="2.Memcache是基于libevent，libevent是个高性能网络库，也是基于Reactor模型。"></a>2.Memcache是基于libevent，libevent是个高性能网络库，也是基于Reactor模型。</h2><p>1.memcached是多线程的，使用<strong>master-worker</strong>的方式，<strong>master线程监听端口，建立连接，然后顺序分配给各个worker线程</strong>。</p>
<p>2.每一个worker线程都有一个event loop，它们服务不同的客户端。 </p>
<p><strong>connection</strong>：</p>
<p>1) master线程和worker线程之间使用管道通信，读端加入event loop，监听可读事件。</p>
<p><strong>2) 每个worker线程都有一个就绪连接队列</strong>，master线程连接连接后，将连接的item放入这个队列，然后往该线程的管道的写端写入一个connect命令。</p>
<p>3) 这样event loop中加入的管道读端就会就绪，worker线程读取命令，解析命令发现是有连接，然后就会去自己的就绪队列中获取连接，并进行处理。</p>
<p><img src="2.png" alt=""></p>
<p>mencached线程池分析 <a href="http://blog.csdn.net/flyqwang/article/details/18814797" target="_blank" rel="noopener">http://blog.csdn.net/flyqwang/article/details/18814797</a> </p>
<p>属于multi-reactors模式，不管是master线程还是worker线程，都要处理事件，master只处理连接事件，worker处理读写事件。</p>
<h2 id="3-Nginx是多进程服务器，Memcache是多线程服务器，但都是采用Multi-Reactors模式。"><a href="#3-Nginx是多进程服务器，Memcache是多线程服务器，但都是采用Multi-Reactors模式。" class="headerlink" title="3.Nginx是多进程服务器，Memcache是多线程服务器，但都是采用Multi-Reactors模式。"></a>3.Nginx是多进程服务器，Memcache是多线程服务器，但都是采用Multi-Reactors模式。</h2><p><img src="3.png" alt=""></p>
<p><img src="4.png" alt=""></p>
<p>从上图可以看出</p>
<p>1）master进程先建好需要listen的socket后，然后再fork出多个woker进程，这样<strong>每个worker进程都可以去accept这个socket</strong>。</p>
<p>2）当一个client连接到来时，所有accept的worker进程都会受到通知，但只有一个进程可以accept成功，其它的则会accept失败。Nginx提供了一把共享锁accept_mutex来保证同一时刻只有一个worker进程在accept连接，从而解决惊群问题。</p>
<p>3）当一个worker进程accept这个连接后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完成的请求就结束了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/04/怎么写一个高性能的服务器(三)：开源分析/" data-id="cjecqlwmh00022wx9v7mpka9p" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-怎么写一个高性能的服务器(二)：编程细节" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/怎么写一个高性能的服务器(二)：编程细节/" class="article-date">
  <time datetime="2018-03-04T09:58:13.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/怎么写一个高性能的服务器(二)：编程细节/">怎么写一个高性能的服务器(二)：编程细节</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看了这个系列做的整理<a href="http://blog.csdn.net/voidccc/article/details/8719752" target="_blank" rel="noopener">http://blog.csdn.net/voidccc/article/details/8719752</a></p>
<h2 id="1-最简单的epoll处理"><a href="#1-最简单的epoll处理" class="headerlink" title="1.最简单的epoll处理"></a>1.最简单的epoll处理</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用epoll的三个函数</span><br><span class="line">int epoll_create(int size) 创建一个epoll文件描述符</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event) 将socket描述符加入/移出epoll监听，修改注册事件</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout) 在epoll描述符上等待事件的发生，并获得事件</span><br></pre></td></tr></table></figure>
<h2 id="2-Reactor"><a href="#2-Reactor" class="headerlink" title="2.Reactor"></a>2.Reactor</h2><p><img src="1.png" alt=""></p>
<h3 id="多了3个类，一个是事件分发器类，一个IO复用类，一个事件处理类。"><a href="#多了3个类，一个是事件分发器类，一个IO复用类，一个事件处理类。" class="headerlink" title="多了3个类，一个是事件分发器类，一个IO复用类，一个事件处理类。"></a>多了3个类，一个是事件分发器类，一个IO复用类，一个事件处理类。</h3><p><strong>1）Channel类：每个Channel对象自始至终只负责一个文件描述符的IO事件分发</strong></p>
<p><strong>以前是用epoll_wait获得事件后，直接就进行了事件处理；</strong></p>
<p><strong>现在通过添加Channel，程序终于可以将事件处理程序写在一个单独的函数中，然后将这个函数注册到Channel上。（注册–回调）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Channel*&gt; channels; </span><br><span class="line"><span class="number">123</span>         <span class="keyword">int</span> fds = epoll_wait(_epollfd, _events, MAX_EVENTS, <span class="number">-1</span>); </span><br><span class="line">...         ... </span><br><span class="line"><span class="number">129</span>         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fds; i++) </span><br><span class="line"><span class="number">130</span>         &#123; </span><br><span class="line"><span class="number">131</span>             Channel* pChannel = <span class="keyword">static_cast</span>&lt;Channel*&gt;(_events[i].data.ptr); </span><br><span class="line"><span class="number">132</span>             pChannel-&gt;setRevents(_events[i].events); </span><br><span class="line"><span class="number">133</span>             channels.push_back(pChannel); </span><br><span class="line"><span class="number">134</span>         &#125; </span><br><span class="line"><span class="number">135</span>  </span><br><span class="line"><span class="number">136</span>         <span class="built_in">vector</span>&lt;Channel*&gt;::iterator it; </span><br><span class="line"><span class="number">137</span>         <span class="keyword">for</span>(it = channels.begin(); it != channels.end(); ++it) </span><br><span class="line"><span class="number">138</span>         &#123; </span><br><span class="line"><span class="number">139</span>             (*it)-&gt;handleEvent(); </span><br><span class="line"><span class="number">140</span>         &#125; </span><br><span class="line"> </span><br><span class="line">第一步<span class="number">129</span>行到<span class="number">134</span>行 ，遍历所有的事件，从其data字段中拿出和这个socket相关的Channel指针，并且将其_revents字段填充好，最后将Channel插入到<span class="built_in">vector</span>中</span><br><span class="line">第二步<span class="number">136</span>行到<span class="number">140</span>行，遍历<span class="built_in">vector</span>，逐一调用其中的handleEvent方法。</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>注册</span><br><span class="line">pChannel-&gt;setCallBack(<span class="keyword">this</span>); </span><br><span class="line">pChannel-&gt;enableReading(); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="number">2.</span>handleEvent里面回调</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> Channel::handleEvent()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>(_revents &amp; EPOLLIN)</span><br><span class="line"> </span><br><span class="line">      _callBack-&gt;run(_sockfd);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在只有两种事件，<strong>接受新连接</strong>和<strong>读写数据</strong>，之前epoll是放在一起处理了。</p>
<p>现在加入了<strong>Acceptor</strong>和<strong>TcpConnection</strong>，终于可以将事件分配到独立的类处理了</p>
<p>这也是应该的，因为接受连接和读写数据根本就是两种性质的事件，处理方式也完全不同，理应放到两个不同的类中。</p>
<h2 id="2）Acceptor类：accept到连接就交给TcpServer创建"><a href="#2）Acceptor类：accept到连接就交给TcpServer创建" class="headerlink" title="2）Acceptor类：accept到连接就交给TcpServer创建"></a><strong>2）Acceptor类：accept到连接就交给TcpServer创建</strong></h2><h2 id="3）TcpConnection类：由TcpServer所创建，然后开始读写数据"><a href="#3）TcpConnection类：由TcpServer所创建，然后开始读写数据" class="headerlink" title="3）TcpConnection类：由TcpServer所创建，然后开始读写数据"></a><strong>3）TcpConnection类：由TcpServer所创建，然后开始读写数据</strong></h2><h2 id="4）EvenLoop类和Epoll类："><a href="#4）EvenLoop类和Epoll类：" class="headerlink" title="4）EvenLoop类和Epoll类："></a><strong>4）EvenLoop类和Epoll类：</strong></h2><p>1 先来看EventLoop，根据名字可以猜测这个类的作用是事件循环，其实这个类就是用来包装for循环的，也就是那个套在epoll_wait外面的for循环，<strong><u>这个for循环可以说是整个程序最核心的部分，for循环等待在epoll_wait上，然后遍历返回的每个事件，先通知到Channel，然后由Channel通知到最终的事件处理程序（位于Acceptor和TcpConnection中）。</u></strong>在上一个版本中。for循环位于TcpServer里，现在我们把它移动到EventLoop的loop方法里，用while代替for，作用跟之前的for循环一样：等待在epoll_wait上，当有事件发生时，回调Channel。当然，EventLoop::loop()不是直接调用epoll_wait，而是使用了其包装类Epoll。</p>
<p>2 Epoll类的作用是包装epoll文件描述符，<strong>它最重要的成员变量是一个epoll文件描述符，最重要的两个方法是poll和update。</strong><u><strong>poll方法包装了epoll_wait，在epoll描述符上等待事件的发生，当有事件发生后将新建的Channel填充到vector中，update方法包装了epoll_ctl，用来在epoll文件描述符上添加/修改/删除事件。update接收一个Channel作为参数，通过这个Channel可以获得要注册的事件(Channel::getEvents()方法)。</strong></u>以后所有涉及epoll描述符的操作都通过Epoll的这两个方法来完成。EventLoop本来是应该包括一个epoll描述符的，loop方法通过一个循环来调用epoll_wait，而现在epoll描述符在Epoll中，所以EventLoop只需要包含一个Epoll成员变量即可。EventLoop在循环中只需要调用Epoll::poll()方法就可以获得Channel列表，不需要直接调用epoll_wait了。</p>
<p>3 <strong>Epoll和EventLoop应该是一一对应的关系，每个EventLoop有且只有一个Epoll。</strong> 在原始的muduo中，为了兼顾epoll/poll编程，作者为IO复用写了公共父类Poller，这里我进行了简化，直接实现了一个epoll的包装类Epoll而忽率了poll。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventLoop::loop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!_quit)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Channel*&gt; channels;</span><br><span class="line">        <span class="comment">// epoll类的操作</span></span><br><span class="line">        _poller-&gt;poll(&amp;channels);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">vector</span>&lt;Channel*&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(it = channels.begin(); it != channels.end(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            (*it)-&gt;handleEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Epoll::poll(<span class="built_in">vector</span>&lt;Channel*&gt;* pChannels)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fds = ::epoll_wait(_epollfd, _events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(fds == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"epoll_wait error, errno:"</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fds; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Channel* pChannel = <span class="keyword">static_cast</span>&lt;Channel*&gt;(_events[i].data.ptr);</span><br><span class="line">        pChannel-&gt;setRevents(_events[i].events);</span><br><span class="line">        pChannels-&gt;push_back(pChannel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-缓冲区"><a href="#3-缓冲区" class="headerlink" title="3.缓冲区"></a>3.缓冲区</h2><p>1） 输出缓冲区的实现：TcpConnection添加了一个代表发送缓冲区的成员变量_outBuf。用户将100k数据通过TcpConnection::send送给网络库，<strong>网络库先检查输出缓冲区是否为空(_outBuf-&gt;empty())，如果为空说明现在没有等待发送的数据，就直接将这100k数据送给write系统调用，看下操作系统能接受多少，然后将剩余的没发送玩的数据添加到输出缓冲区的尾部。</strong>如果发送缓冲区不为空<strong>，说明之前已经堆积了一些数据则本次操作就不尝试write了，直接将100k数据附加在发送缓冲区后。</strong>注意在将数据加入发送缓冲区后会将<strong>EPOLLOUT事件</strong>注册到epoll文件描述符(98行)。<strong>只有这样才能接到epoll文件描述符的通知来继续发送剩余的数据。</strong>当操作系统发现自己的缓冲区有更多可用空间时，通过epoll_wait返回来告知网络库，可以继续发了，这时Channel::handleWrite被触发，Channel::handleWrite会调用到TcpConnection::handleWrite，后者将剩余的数据通过write继续发送，<strong>并且在全部数据发送完毕后取消关注EPOLLOUT事件</strong>(76行)。<strong>取消关注EPOLLOUT非常关键，如果没有这一步，epoll_wait将在每次调用epoll_wait()时都立刻返回EPOLLOUT，因为每当操作系统有更多的发送缓冲区可以被填满时都会通知网络库，而网络库因为没有更多要发送的数据送给操作系统导致其无休止的通知。</strong></p>
<p>3） 输入缓冲区的实现：TcpConnection添加了一个代表接收缓冲区的成员变量_inBuf，在每次handleRead()回调被调用时，使用read系统调用将数据读出来然后追加到输入缓冲区中，并通知用户。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TcpConnection::send(<span class="keyword">const</span> <span class="built_in">string</span>&amp; message)&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(_outBuf-&gt;empty())&#123;</span><br><span class="line">        n = ::write(_sockfd, message.c_str(), message.size());</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"write error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( n &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(message.size()))&#123;</span><br><span class="line">        *_outBuf += message.substr(n, message.size());</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(_pChannel-&gt;isWriting())&#123;</span><br><span class="line">            <span class="comment">//add EPOLLOUT</span></span><br><span class="line">            _pChannel-&gt;enableWriting();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-定时事件"><a href="#4-定时事件" class="headerlink" title="4.定时事件"></a>4.定时事件</h2><p>两种思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">思路A</span><br><span class="line"></span><br><span class="line">定义一个定时器，维护一条定时器链表。 （Redis是链表，Nginx是红黑树）</span><br><span class="line">每个定时器包括了超时时间和回调函数，在链表中按照超时时间升序排列。</span><br><span class="line">每次主循环，首先获取链表中最小超时时间t，也就是说t时间后将处理满足条件定时事件，然后传入epoll_wait。</span><br><span class="line">epoll_wait返回后会有两种情况： </span><br><span class="line">1.t未到便发生了I/O事件。 </span><br><span class="line">2.t到了无I/O事件发生。</span><br><span class="line">返回后先处理I/O事件。然后再处理定时事件。 </span><br><span class="line">由于情况1我们会花费时间来处理I/O事件，所以我们处理定时事件的流程是先获取系统时间，然后遍历链表处理符合条件的事件（时间到了）。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思路B</span><br><span class="line"></span><br><span class="line">timerfd_create(2)把时间变成了一个文件描述符，该文件描述符在定时器超时的那一刻变得可读，这样就能很方便的融入epoll中，用统一的方式来处理IO时间和超时事件。</span><br></pre></td></tr></table></figure>
<h2 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5.多线程"></a>5.多线程</h2><p>上面是个基础框架，单线程的，虽然已经能够hold住小部分并发（这个具体量级需要测试），但是现代计算机都不会是简单的单核计算机，就跑一个线程，多少有点浪费，我8核的Ubuntu，你不要看不起我，所以要上多线程。</p>
<p>多线程具体怎么上呢，网上也有很多文章介绍，比如这篇博客都介绍了<a href="http://blog.csdn.net/yusiguyuan/article/details/17591613" target="_blank" rel="noopener">http://blog.csdn.net/yusiguyuan/article/details/17591613</a></p>
<p>总结起来就是3种比较高效，推荐第3种。</p>
<p>1.<strong>reactor + thread pool</strong>（能适应密集计算）</p>
<p>2.<strong>multiple reactors</strong>（能适应更大的突发I/O）</p>
<p>3.<strong>multiple reactors + thread pool</strong>（one loop per thread + threadpool）（突发I/O与密集计算），subReactor可以有多个，但threadpool只有一个。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/04/怎么写一个高性能的服务器(二)：编程细节/" data-id="cjecqlwmr00042wx92vwqh7zd" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-怎么写一个高性能的服务器(一)：概述" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/怎么写一个高性能的服务器(一)：概述/" class="article-date">
  <time datetime="2018-03-04T08:08:47.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/怎么写一个高性能的服务器(一)：概述/">怎么写一个高性能的服务器(一)：概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>写一个高性能服务器，像redis、memcache和nginx那样，支撑很高的并发，稳定地解决性能问题，其实并不是件很难的事。</p>
<p><strong>本文先从网络编程的细节出发，讲讲网络编程会碰到的问题；再介绍业界流行到2016年的事件驱动模型Reactor，这个模型是并发编程必须要学习的。</strong></p>
<p>为什么说流行到2016年呢？因为2016年Go语言火遍全球，Go语言采用的并发编程模型就是– goroutine），将开发者从各种事件回调中解放出来，代码编写及维护更加人性化。</p>
<p>讲完Reactor后就讲讲redis、memcache和nginx，毕竟它们都是基于这个模型的。</p>
<p><img src="1.png" alt=""></p>
<p>一、从问题出发</p>
<p>写一个服务器，跟一个客户端建立连接，然后处理请求。不管用什么语言，php还是java，都是很简单的事。</p>
<p>一般步骤都是bind-&gt;listen-&gt;accept之后就可以跟客户端互相交流了。</p>
<p><img src="2.png" alt=""></p>
<p>如果客户端增多，一个服务器要跟多个客户端交流，这时候换成C/C++，引入epoll多路复用也可以了。</p>
<p>但这时候的交流并不是高效的，一旦碰到下面的问题，服务器不做点什么就很容易宕机。</p>
<ol>
<li>如何给客户端发送数据？</li>
</ol>
<p>​    <strong>好像一个send或者write函数就可以了，但send或write 1M数据和1G数据肯定是不一样的，平时下载电子书跟下载小电影也能看出来</strong></p>
<p>​      2. 如何正确关闭连接？</p>
<p>​         <strong>服务器发完数据了，一般都觉得没什么事就把连接关了吧。但问题来了，可能客户端还有数据要发送给你，因为网络原因或者其他原因，还在路上。</strong></p>
<p><strong>等到它网络好了，发过来了，而服务器已经关了，这是很沮丧的，导致数据丢失。</strong></p>
<h3 id="二、解决问题"><a href="#二、解决问题" class="headerlink" title="二、解决问题"></a>二、解决问题</h3><p>首先看<strong>socket缓冲区</strong></p>
<p>1）每个 socket 被创建后，都会分配两个缓冲区，<strong>输入缓冲区和输出缓冲区</strong>。</p>
<p><img src="3.png" alt=""></p>
<p>2）write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。</p>
<p>​     一旦将数据写入到缓冲区，<strong>函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络</strong>，这些都是TCP协议负责的事情。</p>
<p>3）<strong>TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络</strong>，</p>
<p>​      这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。</p>
<p>4）read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。</p>
<h3 id="解决第1个问题"><a href="#解决第1个问题" class="headerlink" title="解决第1个问题"></a>解决第1个问题</h3><p>无论是给客户端发送数据，还是接收客户端数据，大小是不可知的，你不能只有电子书，也要有小电影。</p>
<p>参考socket缓冲区，如果所要发送的数据过大，先把能发送的给发送出去，<strong>剩下的我们需要将其暂存起来，所以我们需要建立一个“发送缓冲区”</strong>。</p>
<p>发送缓冲区不仅存放本次没有发完的数据，还用来存放在发送过程中，新的需要发送的数据。</p>
<p>为了保证顺序，<strong>新的数据应该追加在当前剩下的数据的后面，发送的时候从发送缓冲区的头部开始发送。也就是说先来的先发送，后来的后发送。</strong></p>
<p><strong>接收缓冲区也是同理。</strong></p>
<h3 id="解决第1个问题-1"><a href="#解决第1个问题-1" class="headerlink" title="解决第1个问题"></a>解决第1个问题</h3><p>无论是给客户端发送数据，还是接收客户端数据，大小是不可知的，你不能只有电子书，也要有小电影。</p>
<p>参考socket缓冲区，如果所要发送的数据过大，先把能发送的给发送出去，<strong>剩下的我们需要将其暂存起来，所以我们需要建立一个“发送缓冲区”</strong>。</p>
<p>发送缓冲区不仅存放本次没有发完的数据，还用来存放在发送过程中，新的需要发送的数据。</p>
<p>为了保证顺序，<strong>新的数据应该追加在当前剩下的数据的后面，发送的时候从发送缓冲区的头部开始发送。也就是说先来的先发送，后来的后发送。</strong></p>
<p><strong>接收缓冲区也是同理。</strong></p>
<h3 id="解决第2个问题"><a href="#解决第2个问题" class="headerlink" title="解决第2个问题"></a><strong>解决第2个问题</strong></h3><p>被动关闭连接和主动关闭连接</p>
<p>1）在实际的应用中，被动关闭连接是由于我们检测到了连接的异常事件，比如EPOLLERR，<strong>或者对端关闭连接，send或recv返回0，</strong>这个时候这路连接已经没有存在必要的意义了，我们被迫关闭连接。</p>
<p>2）而主动关闭连接，是我们主动调用close/closesocket来关闭连接。比如客户端给我们发送非法的数据，比如一些网络攻击的尝试性数据包。这个时候出于安全考虑，我们关闭socket连接。</p>
<p>第2个问题的出现场景，主要是服务器不确定接收的数据是否完整。</p>
<p>应对这种问题，很明显地需要采用被动关闭方式。</p>
<p><strong>被动关闭：客户端先关闭连接（调用close或者shutdown函数）， 然后服务器从连接中read返回0，得知客户端已经关闭其方向上的连接，此时就会触发关闭逻辑。</strong></p>
<p><strong>具体来说，服务器处理完数据之后（收到EOF，逻辑处理，向客户端发送数据），关闭了服务器到客户端方向的写操作，当客户端收到该关闭信息后，会立即关闭本方向的连接。然后等客户端shutdown或者close之后，服务器从连接中read读到0，于是服务器关闭连接。</strong></p>
<p><strong>shutdown函数具体参考<a href="http://c.biancheng.net/cpp/html/3044.html" target="_blank" rel="noopener">http://c.biancheng.net/cpp/html/3044.html</a></strong></p>
<h3 id="这两个问题是比较经典的问题，第2个问题在知乎上也有讨论https-www-zhihu-com-question-48871684"><a href="#这两个问题是比较经典的问题，第2个问题在知乎上也有讨论https-www-zhihu-com-question-48871684" class="headerlink" title="这两个问题是比较经典的问题，第2个问题在知乎上也有讨论https://www.zhihu.com/question/48871684"></a>这两个问题是比较经典的问题，第2个问题在知乎上也有讨论<a href="https://www.zhihu.com/question/48871684" target="_blank" rel="noopener">https://www.zhihu.com/question/48871684</a></h3><p><strong>分享会上hugo提出的问题，半关闭是什么状态？</strong></p>
<p> 客户端主动关闭时，发出FIN包，收到服务器的ACK，<strong>客户端停留在FIN_WAIT2状态</strong>。而服务端收到FIN，发出ACK后，<strong>停留在COLSE_WAIT状态</strong>。<br> 这个CLOSE_WAIT状态非常讨厌，它持续的时间非常长，服务器端如果积攒大量的COLSE_WAIT状态的socket，有可能将服务器资源耗尽，进而无法提供服务。</p>
<p><a href="http://blog.chinaunix.net/uid-29075379-id-3896846.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-29075379-id-3896846.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/04/怎么写一个高性能的服务器(一)：概述/" data-id="cjecqlwmp00032wx9bihb1017" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-通过core文件解决SIGSEGV问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/通过core文件解决SIGSEGV问题/" class="article-date">
  <time datetime="2018-03-04T07:41:28.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/通过core文件解决SIGSEGV问题/">通过core文件解决SIGSEGV问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>好久没有折腾环境，上周在本地搭建环境，php-fpm起了，nginx也起了，访问接口都是502。看nginx日志，说是后端过早关闭了连接。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> prematurely closed connection while reading response header from upstream, client: <span class="number">127.0.0.1</span>, server: [dev.meijiabang.cn](http://dev.meijiabang.cn/), request...</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt=""></p>
<p>这个问题之前没碰过，感觉要凉了，还是先问问小伙伴吧….于是找ben对比检查下配置文件，各种改配置文件(nginx的rewrite，php-fpm.conf)，我擦，还是502，还是SIGSEGV。</p>
<p>那就只能Google了…</p>
<p>半天过去了，我还是擦，网上都是说段错误，内存错误，可参考价值不高，倒是有一个挺像。</p>
<p><a href="https://github.com/zendtech/ZendOptimizerPlus/issues/176" target="_blank" rel="noopener">https://github.com/zendtech/ZendOptimizerPlus/issues/176</a></p>
<p><img src="2.png" alt=""></p>
<p><strong>鸟哥的回答，说要看看backtrace</strong>。</p>
<p>突然灵光一闪，貌似之前一直想通过core文件调试问题，鸟哥这篇博客有所介绍（<a href="http://www.laruence.com/2011/06/23/2057.html" target="_blank" rel="noopener">http://www.laruence.com/2011/06/23/2057.html</a>）。</p>
<p>很多时候都是这样，看别人写博客，记录踩过的坑，当时总想着怎么重现作者的坑，也一同吸取教训。但往往难以重现。</p>
<p>然而，当自己踩到的时候，常常不是正确的时候，怎么就这时候出现呢…</p>
<h2 id="1-ABOUT-SIGSEGV"><a href="#1-ABOUT-SIGSEGV" class="headerlink" title="1.ABOUT SIGSEGV"></a>1.ABOUT SIGSEGV</h2><p>在<a href="https://zh.wikipedia.org/wiki/POSIX" target="_blank" rel="noopener">POSIX</a>兼容的平台上，<strong>SIGSEGV</strong>是当一个<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" target="_blank" rel="noopener">进程</a>执行了一个无效的内存引用，或发生<a href="https://zh.wikipedia.org/wiki/%E6%AE%B5%E9%94%99%E8%AF%AF" target="_blank" rel="noopener">段错误</a>时发送给它的<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">信号</a>)。</p>
<h2 id="2-ABOUT-core"><a href="#2-ABOUT-core" class="headerlink" title="2.ABOUT core"></a>2.ABOUT core</h2><p><strong>core 文件</strong>是大多数 UNIX 系统实现的一种特性，<strong>当进程崩溃时，操作系统会将进程当前的内存映像和一部分相关的调试信息写入 core 文件</strong>，方便人们后面对问题进行定位。</p>
<p>操作系统里面有很多信号（每个信号都有一个名字，且已SIG开头，用正整数表示，Linux系统一般在&lt;bits/signum.h&gt;头文件中定义），分别代表了不同的含义，在Linux系统中，我们<strong>可以通过shell命令 kill -l 来查看系统有哪些信号。</strong>操作系统收到信号时，内核会按照以下三种方式之一去对信号进行处理：</p>
<ul>
<li><strong>忽略此信号</strong>。大多数的信号都可以用这种方式去处理，即内核收到此信号时，对进程不做任何处理，直接忽略。但是SIGKILL和SIGSTOP这两个信号不能被忽略，因为它们向超级用户提供了使进程终止或停止的可靠方法。</li>
<li><strong>捕捉信号</strong>。即我们向内核注册一个信号处理函数，当内核收到某个信号时，就去调用注册的信号处理函数对信号进行处理。比如我们经常使用的命令kill默认发的是SIGTERM终止信号。注意，不能捕捉SIGKILL和SIGSTOP信号。</li>
<li><strong>执行默认动作</strong>。每个系统都有一套自己默认的信号处理函数，即如果我们不显式的去捕捉信号，那内核收到信号时，要么忽略此信号，要么执行默认的操作。可以理解为操作系统有自己默认的信号处理函数。</li>
</ul>
<p>Linux信号有很多，这里我们列举出默认动作中可能产生core文件的信号（摘自《UNIX环境高级编程》第二版）</p>
<table>
<thead>
<tr>
<th>信号名字</th>
<th>说明</th>
<th>默认动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>异常终止（调用abort函数产生此信号）</td>
<td>终止+core</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>硬件故障，比如出现某些内存故障</td>
<td>终止+core</td>
</tr>
<tr>
<td>SIGEMT</td>
<td>硬件故障</td>
<td>终止+core</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>算术异常，比如除以0，浮点溢出等</td>
<td>终止+core</td>
</tr>
<tr>
<td>SIGILL</td>
<td>非法硬件指令</td>
<td>终止+core</td>
</tr>
<tr>
<td>SIGIOT</td>
<td>硬件故障</td>
<td>终止+core</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>终端退出符，比如Ctrl+C</td>
<td>终止+core</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>无效内存引用</td>
<td>终止+core</td>
</tr>
<tr>
<td>SIGSYS</td>
<td>无效系统调用</td>
<td>终止+core</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>超过CPU限制（setrlimit）</td>
<td>终止+core/忽略</td>
</tr>
<tr>
<td>SIGXFSZ</td>
<td>超过文件长度限制（setrlimit）</td>
<td>终止+core/忽略</td>
</tr>
</tbody>
</table>
<p>并非所有场景我们都希望可以生成core文件，因为影响性能。所以还需要重新打开系统的core文件开关，像下图第2个红框，才表示有core文件生成。</p>
<p><img src="3.png" alt=""></p>
<p>有了core文件，还需要会gdb调试才行，不会gdb，会lldb也ok，因为Mac下面默认配的是lldb，于是我就lldb了一下生成的core文件(lldb  core.xxxx)；</p>
<p><img src="4.png" alt=""></p>
<p>如果想真正理解这个backstrace，还要花点时间，但大致能知道，这绝壁是xdebug的问题….（execute_data=<unavailable>）;</unavailable></p>
<p>果断注释掉xdebug，重启php-fpm，哈哈，502消失，各种接口各种访问都正常，真是超级爽。</p>
<p>那问题来了，xdebug是什么问题呢？是配置问题吗，也不是。记得之前是装php5.6还是7的时候装的xdebug，现在是php7.1，于是马上重新编译安装一个跟7.1版本对应的xdebug，不出所料，访问也正常，xdebug也能用。</p>
<p>（完）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/04/通过core文件解决SIGSEGV问题/" data-id="cjecqlwmt00062wx9dieejdhf" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/04/基于swoole的服务治理(二)：RPC/">基于swoole的服务治理</a>
          </li>
        
          <li>
            <a href="/2018/03/04/基于swoole的服务治理(一)：概述/">基于swoole的服务治理(一)：概述</a>
          </li>
        
          <li>
            <a href="/2018/03/04/怎么写一个高性能的服务器(四)：总结/">怎么写一个高性能的服务器(四)：总结</a>
          </li>
        
          <li>
            <a href="/2018/03/04/怎么写一个高性能的服务器(三)：开源分析/">怎么写一个高性能的服务器(三)：开源分析</a>
          </li>
        
          <li>
            <a href="/2018/03/04/怎么写一个高性能的服务器(二)：编程细节/">怎么写一个高性能的服务器(二)：编程细节</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Kyrie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>